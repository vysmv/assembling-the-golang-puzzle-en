# О массивах и слайсах

## О массивах

**Массив в Go — это тип значений, а не указатель на первый элемент (так мной ранее понимались массивы в C из-за того, что массив в выражениях неявно преобразовывался в адрес на первый элемент), и не структура, внутри которой хранится указатель.  
Синтаксическая запись `[N]T` описывает layout значения (форма значения) в памяти.**

Тип `[4]int` сообщает компилятору (на этапе компиляции), что:

* значение занимает `4 × sizeof(int)` байт;
* байты расположены непрерывно;
* элемент, расположенный по смещению `i × sizeof(int)`, имеет тип `int`.

`[4]int` — это чистое значение без ссылочной семантики.

Можно провести аналогию:

* `[4]int` — это чертёж;
* переменная `a` — дом, построенный по этому чертежу;
* адрес — координаты дома.

Дом не хранит координаты внутри себя, но мы можем получить его адрес из факта размещения.

Для доступа к элементу массива указатель внутри массива не нужен.  
При обращении `a[2]` компилятор, зная адрес размещения значения `a`, тип `[4]int`, размер элемента и индекс, генерирует адресную арифметику вида:

addr = base_address(a) + 2 × sizeof(int)


При этом базовый адрес не хранится в массиве — он возникает из факта размещения значения.

> **Дополнительно**
>
> Важно понимать, что индекса как сущности, существующей в памяти, нет.  
> Индекс — это абстракция языка, логический номер элемента.  
> Реальной величиной является смещение в байтах, которое вычисляется компилятором как `index × sizeof(T)`.

Следовательно, из вышесказанного, синтаксическая запись `*[4]int` в семантике языка Go обозначает указатель на одно значение типа `[4]int`, то есть на массив целиком, а не на его первый элемент. А следовательно, становится доступен полный набор операций, определённых языком для типа `[N]T`. Хотя стоит понимать, что числовое значение адреса `&a` (где `a := [4]int{10, 20, 30, 40}`) совпадает с числовым значением адреса `&a[0]`, но тип указателя и семантика интерпретации этого адреса различны.  
А следовательно, в отношении `&a[0]` недоступны операции, определённые языком для типа `[N]T`, так как это указатель на `int`.

То есть на физическом уровне памяти нет отдельной сущности «массив» — есть только непрерывный диапазон байтов. Массив как целое — это не физический объект, а языковая интерпретация диапазона адресов. То есть это абстрактный слой, определяющий, как компилятор воспринимает адрес.  
По сути, смысл проявляется в том, что в Go, если функция принимает `[4]int`, то это приведёт к копированию всего диапазона.  
А если функция принимает `*[4]int`, то это позволит в её теле читать/писать в любой элемент диапазона массива посредством разыменования.  
НО, если, например, функции передавать `a[0]` или `*a[0]`, то в первом случае тип будет `int`, а во втором случае — указатель на `int`. То есть Go не будет позволять работать с диапазоном, а только с одним элементом, потому что это не массив.

Хотя ещё раз повторюсь, что числовое значение адресов у `&[4]int` и `&a[0]` совпадает.

**Дополнительно**

В C функция, принимающая `int*`, не знает размера массива, но программист по соглашению может трактовать указатель как начало массива и использовать адресную арифметику (то есть если в сигнатуре функции указано, что аргумент типа указатель на `int` — `int*`, то я могу передать ей `&a[0]`, но в теле функции посредством адресной арифметики могу получать элементы массива. А в Go это недоступно без пакета `unsafe`.).

**Итог:** тип `[N]T` в Go описывает форму и размер значения в памяти, но не содержит и не подразумевает наличие указателя.  
Адрес значения возникает из факта его размещения, а доступ к элементам реализуется компилятором через адресную арифметику на основе индекса и известного компилятору типа `[N]T`.
